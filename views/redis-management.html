<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Redisç¼“å­˜ç®¡ç† - ç°ä»£å›¾åºŠ</title>
    <link rel="stylesheet" href="/css/style.css">
    <style>
        .redis-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: white;
            border-radius: 8px;
            padding: 20px;
            border: 1px solid #e0e0e0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .stat-card h3 {
            margin: 0 0 15px 0;
            color: #333;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        
        .status-connected {
            background-color: #4CAF50;
        }
        
        .status-disconnected {
            background-color: #f44336;
        }
        
        .status-disabled {
            background-color: #9e9e9e;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #f0f0f0;
        }
        
        .stat-item:last-child {
            border-bottom: none;
        }
        
        .stat-label {
            font-weight: 500;
            color: #666;
        }
        
        .stat-value {
            color: #333;
            font-weight: 600;
        }
        
        .cache-actions {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 30px;
        }
        
        .action-card {
            background: white;
            border-radius: 8px;
            padding: 20px;
            border: 1px solid #e0e0e0;
            text-align: center;
        }
        
        .action-card h4 {
            margin: 0 0 10px 0;
            color: #333;
        }
        
        .action-card p {
            margin: 0 0 15px 0;
            color: #666;
            font-size: 14px;
        }
        
        .btn-danger {
            background-color: #f44336;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        
        .btn-danger:hover {
            background-color: #d32f2f;
        }
        
        .btn-warning {
            background-color: #ff9800;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        
        .btn-warning:hover {
            background-color: #f57c00;
        }
        
        .alert {
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
            font-weight: 500;
        }
        
        .alert-success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .alert-error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .alert-warning {
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        
        .refresh-button {
            background-color: #2196F3;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .refresh-button:hover {
            background-color: #1976D2;
        }
        
        .memory-usage {
            width: 100%;
            height: 20px;
            background-color: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .memory-bar {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #FFC107, #f44336);
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="container header-content">
            <a href="/" class="logo">ç°ä»£å›¾åºŠ</a>
            <nav class="nav">
                <a href="/" class="btn btn-outline">ä¸Šä¼ </a>
                <a href="/gallery" class="btn btn-outline">å›¾ç‰‡åº“</a>
                <a href="/categories" class="btn btn-outline">åˆ†ç±»ç®¡ç†</a>
                <a href="/admin-center" class="btn btn-outline">ç®¡ç†ä¸­å¿ƒ</a>
                <a href="/redis-management" class="btn btn-outline">Redisç®¡ç†</a>
                <a href="/settings" class="btn btn-outline">ç³»ç»Ÿè®¾ç½®</a>
                <button id="toggleDarkMode" class="btn btn-outline">æš—è‰²æ¨¡å¼</button>
                <a href="/logout" class="btn btn-outline">é€€å‡º</a>
            </nav>
        </div>
    </header>

    <div class="container">
        <h1>Redisç¼“å­˜ç®¡ç†</h1>
        
        <button class="refresh-button" onclick="loadRedisStatus()">
            ğŸ”„ åˆ·æ–°çŠ¶æ€
        </button>
        
        <div id="alerts"></div>
        
        <div class="redis-stats" id="redisStats">
            <div class="stat-card">
                <h3>è¿æ¥çŠ¶æ€</h3>
                <div class="stat-item">
                    <span class="stat-label">çŠ¶æ€</span>
                    <span class="stat-value" id="connectionStatus">
                        <span class="status-indicator status-disconnected"></span>
                        æ£€æŸ¥ä¸­...
                    </span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">ä¸»æœº</span>
                    <span class="stat-value" id="redisHost">-</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">ç«¯å£</span>
                    <span class="stat-value" id="redisPort">-</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">æ•°æ®åº“</span>
                    <span class="stat-value" id="redisDb">-</span>
                </div>
            </div>
            
            <div class="stat-card">
                <h3>å†…å­˜ä½¿ç”¨</h3>
                <div class="stat-item">
                    <span class="stat-label">å·²ç”¨å†…å­˜</span>
                    <span class="stat-value" id="usedMemory">-</span>
                </div>
                <div class="memory-usage">
                    <div class="memory-bar" id="memoryBar" style="width: 0%"></div>
                </div>
                <div class="stat-item">
                    <span class="stat-label">æœ€å¤§å†…å­˜</span>
                    <span class="stat-value" id="maxMemory">-</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">æ·˜æ±°ç­–ç•¥</span>
                    <span class="stat-value" id="maxMemoryPolicy">-</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">å†…å­˜ç¢ç‰‡ç‡</span>
                    <span class="stat-value" id="memFragRatio">-</span>
                </div>
            </div>
            
            <div class="stat-card">
                <h3>é”®ç»Ÿè®¡</h3>
                <div class="stat-item">
                    <span class="stat-label">æ€»é”®æ•°</span>
                    <span class="stat-value" id="totalKeys">-</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">å·²è¿‡æœŸé”®</span>
                    <span class="stat-value" id="expiredKeys">-</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">å·²æ·˜æ±°é”®</span>
                    <span class="stat-value" id="evictedKeys">-</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">å‘½ä¸­ç‡</span>
                    <span class="stat-value" id="hitRate">-</span>
                </div>
            </div>
            
            <div class="stat-card">
                <h3>æ€§èƒ½ç»Ÿè®¡</h3>
                <div class="stat-item">
                    <span class="stat-label">æ€»è¿æ¥æ•°</span>
                    <span class="stat-value" id="totalConnections">-</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">æ€»å‘½ä»¤æ•°</span>
                    <span class="stat-value" id="totalCommands">-</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">æ¯ç§’å‘½ä»¤æ•°</span>
                    <span class="stat-value" id="commandsPerSec">-</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">ç½‘ç»œè¾“å…¥</span>
                    <span class="stat-value" id="networkInput">-</span>
                </div>
            </div>
        </div>
        
        <div class="cache-actions">
            <div class="action-card">
                <h4>å†…å­˜é…ç½®</h4>
                <p>åŠ¨æ€è°ƒæ•´Rediså†…å­˜é™åˆ¶å’Œæ·˜æ±°ç­–ç•¥</p>
                <div style="margin-bottom: 10px;">
                    <input type="text" id="maxMemoryInput" placeholder="å¦‚: 512mb, 1gb" style="width: 100%; padding: 8px; margin-bottom: 8px; border: 1px solid #ddd; border-radius: 4px;">
                    <select id="maxMemoryPolicySelect" style="width: 100%; padding: 8px; margin-bottom: 8px; border: 1px solid #ddd; border-radius: 4px;">
                        <option value="">é€‰æ‹©æ·˜æ±°ç­–ç•¥</option>
                        <option value="noeviction">noeviction (ä¸æ·˜æ±°)</option>
                        <option value="allkeys-lru">allkeys-lru (LRUæ‰€æœ‰é”®)</option>
                        <option value="allkeys-lfu">allkeys-lfu (LFUæ‰€æœ‰é”®)</option>
                        <option value="allkeys-random">allkeys-random (éšæœºæ‰€æœ‰é”®)</option>
                        <option value="volatile-lru">volatile-lru (LRUè¿‡æœŸé”®)</option>
                        <option value="volatile-lfu">volatile-lfu (LFUè¿‡æœŸé”®)</option>
                        <option value="volatile-random">volatile-random (éšæœºè¿‡æœŸé”®)</option>
                        <option value="volatile-ttl">volatile-ttl (TTLè¿‡æœŸé”®)</option>
                    </select>
                </div>
                <button class="btn-warning" onclick="configureRedisMemory()">
                    åº”ç”¨é…ç½®
                </button>
            </div>
            
            <div class="action-card">
                <h4>æ¸…é™¤å›¾ç‰‡ç¼“å­˜</h4>
                <p>æ¸…é™¤æ‰€æœ‰å›¾ç‰‡åˆ—è¡¨ç›¸å…³çš„ç¼“å­˜æ•°æ®</p>
                <button class="btn-warning" onclick="invalidateImageCache()">
                    æ¸…é™¤å›¾ç‰‡ç¼“å­˜
                </button>
            </div>
            
            <div class="action-card">
                <h4>æ¸…é™¤é…ç½®ç¼“å­˜</h4>
                <p>æ¸…é™¤ç³»ç»Ÿé…ç½®ç›¸å…³çš„ç¼“å­˜æ•°æ®</p>
                <button class="btn-warning" onclick="invalidateConfigCache()">
                    æ¸…é™¤é…ç½®ç¼“å­˜
                </button>
            </div>
            
            <div class="action-card">
                <h4>æ¸…ç©ºæ‰€æœ‰ç¼“å­˜</h4>
                <p>âš ï¸ è¿™å°†åˆ é™¤Redisä¸­çš„æ‰€æœ‰æ•°æ®</p>
                <button class="btn-danger" onclick="flushAllCache()">
                    æ¸…ç©ºæ‰€æœ‰ç¼“å­˜
                </button>
            </div>

            <div class="action-card">
                <h4>ç¼“å­˜è¿‡æœŸæ—¶é—´é…ç½®</h4>
                <p>è°ƒæ•´ä¸åŒç±»å‹ç¼“å­˜çš„é»˜è®¤è¿‡æœŸæ—¶é—´(TTL)</p>
                
                <div id="ttlConfigForm" style="text-align: left;">
                    <div style="margin-bottom: 10px;">
                        <label style="display: block; margin-bottom: 3px; font-weight: 500;">å›¾ç‰‡åˆ—è¡¨ç¼“å­˜ (ç§’)</label>
                        <input type="number" id="imageListTtl" min="60" max="86400" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;">
                        <small style="color: #666;">å½“å‰: <span id="currentImageListTtl">3600</span>ç§’ (<span id="currentImageListTtlDesc">1å°æ—¶</span>)</small>
                    </div>
                    
                    <div style="margin-bottom: 10px;">
                        <label style="display: block; margin-bottom: 3px; font-weight: 500;">å›¾ç‰‡ä¿¡æ¯ç¼“å­˜ (ç§’)</label>
                        <input type="number" id="imageInfoTtl" min="300" max="172800" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;">
                        <small style="color: #666;">å½“å‰: <span id="currentImageInfoTtl">7200</span>ç§’ (<span id="currentImageInfoTtlDesc">2å°æ—¶</span>)</small>
                    </div>
                    
                    <div style="margin-bottom: 10px;">
                        <label style="display: block; margin-bottom: 3px; font-weight: 500;">ç³»ç»Ÿé…ç½®ç¼“å­˜ (ç§’)</label>
                        <input type="number" id="configTtl" min="60" max="7200" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;">
                        <small style="color: #666;">å½“å‰: <span id="currentConfigTtl">1800</span>ç§’ (<span id="currentConfigTtlDesc">30åˆ†é’Ÿ</span>)</small>
                    </div>
                    
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 3px; font-weight: 500;">APIç¼“å­˜ (ç§’)</label>
                        <input type="number" id="apiCacheTtl" min="30" max="3600" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;">
                        <small style="color: #666;">å½“å‰: <span id="currentApiCacheTtl">600</span>ç§’ (<span id="currentApiCacheTtlDesc">10åˆ†é’Ÿ</span>)</small>
                    </div>
                </div>
                
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <button class="btn-warning" onclick="updateTtlConfig()" style="flex: 1; min-width: 120px;">
                        æ›´æ–°TTLé…ç½®
                    </button>
                    <button class="btn-warning" onclick="resetTtlConfig()" style="flex: 1; min-width: 120px;" title="é‡æ–°ä»ç¯å¢ƒå˜é‡åŠ è½½TTLé…ç½®">
                        é‡ç½®ä¸ºç¯å¢ƒå˜é‡
                    </button>
                </div>
            </div>

            <div class="action-card">
                <h4>ç¼“å­˜é”®ç®¡ç†</h4>
                <p>æŸ¥çœ‹å’Œç®¡ç†å½“å‰çš„ç¼“å­˜é”®åŠå…¶TTLä¿¡æ¯</p>
                
                <div style="margin-bottom: 15px; display: flex; flex-wrap: wrap; gap: 10px;">
                    <button class="btn-warning" onclick="loadCacheInfo()" style="flex: 1; min-width: 120px;">
                        åŠ è½½ç¼“å­˜ä¿¡æ¯
                    </button>
                    <button class="btn-warning" onclick="showCacheDetails()" style="flex: 1; min-width: 120px;">
                        æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
                    </button>
                </div>
                
                <div id="cacheInfoContainer" style="display: none; text-align: left; max-height: 300px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; border-radius: 4px; background: #f9f9f9;">
                    <div id="cacheInfoContent"></div>
                </div>
            </div>
        </div>
        
        <div style="margin-top: 30px;">
            <a href="/" class="button">è¿”å›é¦–é¡µ</a>
            <a href="/debug" class="button">è°ƒè¯•é¡µé¢</a>
        </div>
    </div>

    <script>
        let isLoading = false;

        function showAlert(message, type = 'success') {
            const alertsContainer = document.getElementById('alerts');
            const alert = document.createElement('div');
            alert.className = `alert alert-${type}`;
            alert.textContent = message;
            
            alertsContainer.innerHTML = '';
            alertsContainer.appendChild(alert);
            
            setTimeout(() => {
                alert.remove();
            }, 5000);
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function formatNumber(num) {
            return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
        }

        async function loadRedisStatus() {
            if (isLoading) return;
            isLoading = true;
            
            const refreshButton = document.querySelector('.refresh-button');
            if (refreshButton) {
                refreshButton.textContent = 'ğŸ”„ åŠ è½½ä¸­...';
                refreshButton.disabled = true;
            }
            
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000); // 10ç§’è¶…æ—¶
                
                const response = await fetch('/api/debug/redis-status', {
                    signal: controller.signal,
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (data.success) {
                    updateRedisStatus(data.redis);
                } else {
                    showAlert('è·å–RedisçŠ¶æ€å¤±è´¥: ' + (data.message || 'æœªçŸ¥é”™è¯¯'), 'error');
                    updateRedisStatus({ enabled: false, connected: false, error: data.message || 'æœªçŸ¥é”™è¯¯' });
                }
            } catch (error) {
                let errorMessage = 'ç½‘ç»œè¿æ¥å¤±è´¥';
                if (error.name === 'AbortError') {
                    errorMessage = 'è¯·æ±‚è¶…æ—¶';
                } else if (error.message) {
                    errorMessage = error.message;
                }
                
                console.error('è·å–RedisçŠ¶æ€å¤±è´¥:', error);
                showAlert('è·å–RedisçŠ¶æ€å¤±è´¥: ' + errorMessage, 'error');
                updateRedisStatus({ enabled: false, connected: false, error: errorMessage });
            } finally {
                isLoading = false;
                if (refreshButton) {
                    refreshButton.textContent = 'ğŸ”„ åˆ·æ–°çŠ¶æ€';
                    refreshButton.disabled = false;
                }
            }
        }

        function updateRedisStatus(redisData) {
            const connectionStatus = document.getElementById('connectionStatus');
            const indicator = connectionStatus.querySelector('.status-indicator');
            
            if (!redisData.enabled) {
                indicator.className = 'status-indicator status-disabled';
                connectionStatus.innerHTML = '<span class="status-indicator status-disabled"></span>æœªå¯ç”¨';
                document.getElementById('redisHost').textContent = '-';
                document.getElementById('redisPort').textContent = '-';
                document.getElementById('redisDb').textContent = '-';
                showAlert('Redisæœªå¯ç”¨ã€‚è¯·æ£€æŸ¥é…ç½®æ–‡ä»¶å’Œç¯å¢ƒå˜é‡ã€‚', 'warning');
            } else if (!redisData.connected) {
                indicator.className = 'status-indicator status-disconnected';
                connectionStatus.innerHTML = '<span class="status-indicator status-disconnected"></span>è¿æ¥å¤±è´¥';
                document.getElementById('redisHost').textContent = redisData.config?.host || '-';
                document.getElementById('redisPort').textContent = redisData.config?.port || '-';
                document.getElementById('redisDb').textContent = redisData.config?.db || '-';
                showAlert('Redisè¿æ¥å¤±è´¥: ' + (redisData.error || 'æœªçŸ¥é”™è¯¯'), 'error');
            } else {
                indicator.className = 'status-indicator status-connected';
                connectionStatus.innerHTML = '<span class="status-indicator status-connected"></span>å·²è¿æ¥';
                document.getElementById('redisHost').textContent = redisData.config.host;
                document.getElementById('redisPort').textContent = redisData.config.port;
                document.getElementById('redisDb').textContent = redisData.config.db;
                
                // æ›´æ–°å†…å­˜ä¿¡æ¯
                if (redisData.memoryInfo) {
                    const usedMemory = parseInt(redisData.memoryInfo.used_memory || 0);
                    const maxMemory = parseInt(redisData.memoryInfo.maxmemory || 0);
                    
                    document.getElementById('usedMemory').textContent = formatBytes(usedMemory);
                    document.getElementById('maxMemory').textContent = maxMemory > 0 ? formatBytes(maxMemory) : 'æ— é™åˆ¶';
                    document.getElementById('maxMemoryPolicy').textContent = redisData.memoryInfo['maxmemory-policy'] || '-';
                    document.getElementById('memFragRatio').textContent = redisData.memoryInfo.mem_fragmentation_ratio || '-';
                    
                    // æ›´æ–°å†…å­˜ä½¿ç”¨æ¡
                    if (maxMemory > 0) {
                        const percentage = (usedMemory / maxMemory) * 100;
                        document.getElementById('memoryBar').style.width = Math.min(percentage, 100) + '%';
                    } else {
                        document.getElementById('memoryBar').style.width = '0%';
                    }
                }
                
                // æ›´æ–°é”®ç»Ÿè®¡
                if (redisData.keyspaceInfo) {
                    const dbInfo = redisData.keyspaceInfo[`db${redisData.config.db}`];
                    if (dbInfo) {
                        const keyMatch = dbInfo.match(/keys=(\d+)/);
                        const totalKeys = keyMatch ? parseInt(keyMatch[1]) : 0;
                        document.getElementById('totalKeys').textContent = formatNumber(totalKeys);
                    } else {
                        document.getElementById('totalKeys').textContent = '0';
                    }
                }
                
                // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
                if (redisData.statsInfo) {
                    document.getElementById('expiredKeys').textContent = formatNumber(parseInt(redisData.statsInfo.expired_keys || 0));
                    document.getElementById('evictedKeys').textContent = formatNumber(parseInt(redisData.statsInfo.evicted_keys || 0));
                    document.getElementById('totalConnections').textContent = formatNumber(parseInt(redisData.statsInfo.total_connections_received || 0));
                    document.getElementById('totalCommands').textContent = formatNumber(parseInt(redisData.statsInfo.total_commands_processed || 0));
                    
                    // è®¡ç®—å‘½ä¸­ç‡
                    const hits = parseInt(redisData.statsInfo.keyspace_hits || 0);
                    const misses = parseInt(redisData.statsInfo.keyspace_misses || 0);
                    const total = hits + misses;
                    const hitRate = total > 0 ? ((hits / total) * 100).toFixed(1) + '%' : '-';
                    document.getElementById('hitRate').textContent = hitRate;
                    
                    // è®¡ç®—æ¯ç§’å‘½ä»¤æ•°ï¼ˆç®€å•ä¼°ç®—ï¼‰
                    const commandsPerSec = parseInt(redisData.statsInfo.instantaneous_ops_per_sec || 0);
                    document.getElementById('commandsPerSec').textContent = formatNumber(commandsPerSec);
                }
                
                // æ›´æ–°ç½‘ç»œç»Ÿè®¡
                if (redisData.statsInfo) {
                    const networkInput = parseInt(redisData.statsInfo.total_net_input_bytes || 0);
                    document.getElementById('networkInput').textContent = formatBytes(networkInput);
                }
                
                // é¢„å¡«å……å†…å­˜é…ç½®è¾“å…¥æ¡†
                if (redisData.memoryInfo) {
                    const maxMemoryInput = document.getElementById('maxMemoryInput');
                    const maxMemoryPolicySelect = document.getElementById('maxMemoryPolicySelect');
                    
                    if (maxMemoryInput && !maxMemoryInput.value) {
                        const currentMaxMemory = redisData.memoryInfo.maxmemory;
                        if (currentMaxMemory && currentMaxMemory !== '0') {
                            // è½¬æ¢å­—èŠ‚ä¸ºåˆé€‚çš„å•ä½
                            const bytes = parseInt(currentMaxMemory);
                            if (bytes >= 1024 * 1024 * 1024) {
                                maxMemoryInput.placeholder = `å½“å‰: ${(bytes / (1024 * 1024 * 1024)).toFixed(1)}gb`;
                            } else if (bytes >= 1024 * 1024) {
                                maxMemoryInput.placeholder = `å½“å‰: ${(bytes / (1024 * 1024)).toFixed(0)}mb`;
                            } else {
                                maxMemoryInput.placeholder = `å½“å‰: ${bytes}b`;
                            }
                        }
                    }
                    
                    if (maxMemoryPolicySelect) {
                        const currentPolicy = redisData.memoryInfo['maxmemory-policy'];
                        if (currentPolicy) {
                            // æ›´æ–°é€‰æ‹©æ¡†çš„é»˜è®¤é€‰é¡¹æ˜¾ç¤º
                            const defaultOption = maxMemoryPolicySelect.querySelector('option[value=""]');
                            if (defaultOption) {
                                defaultOption.textContent = `å½“å‰ç­–ç•¥: ${currentPolicy}`;
                            }
                        }
                    }
                }
            }
            
            // é‡ç½®å…¶ä»–ç»Ÿè®¡ä¿¡æ¯å¦‚æœRedisä¸å¯ç”¨
            if (!redisData.enabled || !redisData.connected) {
                const fieldsToReset = [
                    'usedMemory', 'maxMemory', 'maxMemoryPolicy', 'memFragRatio',
                    'totalKeys', 'expiredKeys', 'evictedKeys', 'hitRate',
                    'totalConnections', 'totalCommands', 'commandsPerSec', 'networkInput'
                ];
                
                fieldsToReset.forEach(fieldId => {
                    const element = document.getElementById(fieldId);
                    if (element) {
                        element.textContent = '-';
                    }
                });
                
                const memoryBar = document.getElementById('memoryBar');
                if (memoryBar) {
                    memoryBar.style.width = '0%';
                }
            }
        }

        async function invalidateImageCache() {
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);
                
                const response = await fetch('/api/cache/invalidate-images', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (data.success) {
                    showAlert(data.message, 'success');
                    loadRedisStatus();
                } else {
                    showAlert('æ“ä½œå¤±è´¥: ' + (data.message || 'æœªçŸ¥é”™è¯¯'), 'error');
                }
            } catch (error) {
                let errorMessage = 'æ“ä½œå¤±è´¥';
                if (error.name === 'AbortError') {
                    errorMessage = 'è¯·æ±‚è¶…æ—¶';
                } else if (error.message) {
                    errorMessage = error.message;
                }
                showAlert(errorMessage, 'error');
                console.error('æ¸…é™¤å›¾ç‰‡ç¼“å­˜å¤±è´¥:', error);
            }
        }

        async function invalidateConfigCache() {
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);
                
                const response = await fetch('/api/cache/invalidate-config', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (data.success) {
                    showAlert(data.message, 'success');
                    loadRedisStatus();
                } else {
                    showAlert('æ“ä½œå¤±è´¥: ' + (data.message || 'æœªçŸ¥é”™è¯¯'), 'error');
                }
            } catch (error) {
                let errorMessage = 'æ“ä½œå¤±è´¥';
                if (error.name === 'AbortError') {
                    errorMessage = 'è¯·æ±‚è¶…æ—¶';
                } else if (error.message) {
                    errorMessage = error.message;
                }
                showAlert(errorMessage, 'error');
                console.error('æ¸…é™¤é…ç½®ç¼“å­˜å¤±è´¥:', error);
            }
        }

        async function flushAllCache() {
            if (!confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰Redisç¼“å­˜æ•°æ®å—ï¼Ÿè¿™ä¸ªæ“ä½œä¸å¯æ¢å¤ï¼')) {
                return;
            }
            
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);
                
                const response = await fetch('/api/cache/flush', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (data.success) {
                    showAlert(data.message, 'success');
                    loadRedisStatus();
                } else {
                    showAlert('æ“ä½œå¤±è´¥: ' + (data.message || 'æœªçŸ¥é”™è¯¯'), 'error');
                }
            } catch (error) {
                let errorMessage = 'æ“ä½œå¤±è´¥';
                if (error.name === 'AbortError') {
                    errorMessage = 'è¯·æ±‚è¶…æ—¶';
                } else if (error.message) {
                    errorMessage = error.message;
                }
                showAlert(errorMessage, 'error');
                console.error('æ¸…ç©ºæ‰€æœ‰ç¼“å­˜å¤±è´¥:', error);
            }
        }

        async function configureRedisMemory() {
            const maxMemory = document.getElementById('maxMemoryInput').value.trim();
            const maxMemoryPolicy = document.getElementById('maxMemoryPolicySelect').value;
            
            if (!maxMemory && !maxMemoryPolicy) {
                showAlert('è¯·è‡³å°‘å¡«å†™ä¸€é¡¹é…ç½®', 'warning');
                return;
            }
            
            // éªŒè¯å†…å­˜æ ¼å¼
            if (maxMemory) {
                const memoryRegex = /^\d+(\.\d+)?(b|kb|mb|gb)$/i;
                if (!memoryRegex.test(maxMemory)) {
                    showAlert('å†…å­˜æ ¼å¼ä¸æ­£ç¡®ï¼Œè¯·ä½¿ç”¨å¦‚: 512mb, 1gb ç­‰æ ¼å¼', 'error');
                    return;
                }
            }
            
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);
                
                const requestBody = {};
                if (maxMemory) requestBody.maxMemory = maxMemory;
                if (maxMemoryPolicy) requestBody.maxMemoryPolicy = maxMemoryPolicy;
                
                const response = await fetch('/api/redis/configure-memory', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (data.success) {
                    showAlert(data.message, 'success');
                    // æ¸…ç©ºè¾“å…¥æ¡†
                    document.getElementById('maxMemoryInput').value = '';
                    document.getElementById('maxMemoryPolicySelect').value = '';
                    // åˆ·æ–°çŠ¶æ€
                    loadRedisStatus();
                } else {
                    showAlert('é…ç½®å¤±è´¥: ' + (data.message || 'æœªçŸ¥é”™è¯¯'), 'error');
                }
            } catch (error) {
                let errorMessage = 'é…ç½®å¤±è´¥';
                if (error.name === 'AbortError') {
                    errorMessage = 'è¯·æ±‚è¶…æ—¶';
                } else if (error.message) {
                    errorMessage = error.message;
                }
                showAlert(errorMessage, 'error');
                console.error('Rediså†…å­˜é…ç½®å¤±è´¥:', error);
            }
        }

        async function updateTtlConfig() {
            try {
                const ttlConfig = {
                    imageList: parseInt(document.getElementById('imageListTtl').value) || null,
                    imageInfo: parseInt(document.getElementById('imageInfoTtl').value) || null,
                    config: parseInt(document.getElementById('configTtl').value) || null,
                    apiCache: parseInt(document.getElementById('apiCacheTtl').value) || null
                };

                // è¿‡æ»¤æ‰ç©ºå€¼
                const filteredConfig = {};
                for (const [key, value] of Object.entries(ttlConfig)) {
                    if (value !== null && value > 0) {
                        filteredConfig[key] = value;
                    }
                }

                if (Object.keys(filteredConfig).length === 0) {
                    showAlert('è¯·è‡³å°‘å¡«å†™ä¸€é¡¹TTLé…ç½®', 'warning');
                    return;
                }

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);
                
                const response = await fetch('/api/redis/ttl-config', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ ttlConfig: filteredConfig }),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (data.success) {
                    showAlert(data.message, 'success');
                    // æ›´æ–°æ˜¾ç¤ºçš„å½“å‰å€¼
                    updateTtlDisplay(data.config);
                    // æ¸…ç©ºè¾“å…¥æ¡†
                    document.getElementById('imageListTtl').value = '';
                    document.getElementById('imageInfoTtl').value = '';
                    document.getElementById('configTtl').value = '';
                    document.getElementById('apiCacheTtl').value = '';
                } else {
                    showAlert('TTLé…ç½®æ›´æ–°å¤±è´¥: ' + (data.message || 'æœªçŸ¥é”™è¯¯'), 'error');
                }
            } catch (error) {
                let errorMessage = 'TTLé…ç½®æ›´æ–°å¤±è´¥';
                if (error.name === 'AbortError') {
                    errorMessage = 'è¯·æ±‚è¶…æ—¶';
                } else if (error.message) {
                    errorMessage = error.message;
                }
                showAlert(errorMessage, 'error');
                console.error('TTLé…ç½®æ›´æ–°å¤±è´¥:', error);
            }
        }

        async function loadTtlConfig() {
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);
                
                const response = await fetch('/api/redis/ttl-config', {
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (data.success) {
                    updateTtlDisplay(data.config);
                    // è¾“å‡ºè°ƒè¯•ä¿¡æ¯åˆ°æ§åˆ¶å°
                    if (data.debug) {
                        console.log('ç¯å¢ƒå˜é‡TTLé…ç½®:', data.debug.envConfig);
                        console.log('å½“å‰TTLé…ç½®:', data.debug.currentConfig);
                    }
                }
            } catch (error) {
                console.error('åŠ è½½TTLé…ç½®å¤±è´¥:', error);
            }
        }

        async function resetTtlConfig() {
            if (!confirm('ç¡®å®šè¦é‡ç½®TTLé…ç½®å—ï¼Ÿè¿™å°†æ¸…é™¤æ‰€æœ‰æ‰‹åŠ¨è®¾ç½®çš„å€¼ï¼Œé‡æ–°ä»ç¯å¢ƒå˜é‡åŠ è½½é…ç½®ã€‚')) {
                return;
            }
            
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000);
                
                const response = await fetch('/api/redis/ttl-config/reset', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (data.success) {
                    showAlert(data.message, 'success');
                    updateTtlDisplay(data.config);
                } else {
                    showAlert('TTLé…ç½®é‡ç½®å¤±è´¥: ' + (data.message || 'æœªçŸ¥é”™è¯¯'), 'error');
                }
            } catch (error) {
                let errorMessage = 'TTLé…ç½®é‡ç½®å¤±è´¥';
                if (error.name === 'AbortError') {
                    errorMessage = 'è¯·æ±‚è¶…æ—¶';
                } else if (error.message) {
                    errorMessage = error.message;
                }
                showAlert(errorMessage, 'error');
                console.error('TTLé…ç½®é‡ç½®å¤±è´¥:', error);
            }
        }

        function updateTtlDisplay(config) {
            if (config) {
                const imageListTtl = config.imageList || 3600;
                const imageInfoTtl = config.imageInfo || 7200;
                const configTtl = config.config || 1800;
                const apiCacheTtl = config.apiCache || 600;

                document.getElementById('currentImageListTtl').textContent = imageListTtl;
                document.getElementById('currentImageInfoTtl').textContent = imageInfoTtl;
                document.getElementById('currentConfigTtl').textContent = configTtl;
                document.getElementById('currentApiCacheTtl').textContent = apiCacheTtl;

                // æ›´æ–°æ˜¾ç¤ºçš„æ—¶é—´æè¿°
                document.getElementById('currentImageListTtlDesc').textContent = formatTimeDescription(imageListTtl);
                document.getElementById('currentImageInfoTtlDesc').textContent = formatTimeDescription(imageInfoTtl);
                document.getElementById('currentConfigTtlDesc').textContent = formatTimeDescription(configTtl);
                document.getElementById('currentApiCacheTtlDesc').textContent = formatTimeDescription(apiCacheTtl);
            }
        }


        function formatTimeDescription(seconds) {
            if (seconds < 60) return `${seconds}ç§’`;
            if (seconds < 3600) {
                const minutes = Math.round(seconds / 60);
                return `${minutes}åˆ†é’Ÿ`;
            }
            // å¯¹äºå°æ—¶ï¼Œå¦‚æœå¤§äº48å°æ—¶åˆ™åŒæ—¶æ˜¾ç¤ºå¤©æ•°å’Œå°æ—¶æ•°ï¼Œå¦åˆ™åªæ˜¾ç¤ºå°æ—¶
            const hours = seconds / 3600;
            if (hours < 48) {
                const roundedHours = Math.round(hours * 10) / 10; // ä¿ç•™1ä½å°æ•°
                return roundedHours % 1 === 0 ? `${roundedHours}å°æ—¶` : `${roundedHours}å°æ—¶`;
            } else {
                const days = Math.floor(seconds / 86400);
                const remainingHours = Math.round((seconds % 86400) / 3600);
                if (remainingHours === 0) {
                    return `${days}å¤©`;
                } else {
                    return `${days}å¤©${remainingHours}å°æ—¶`;
                }
            }
        }

        function formatTime(seconds) {
            if (seconds <= 0) return 'å·²è¿‡æœŸ';
            if (seconds === -1) return 'æ°¸ä¸è¿‡æœŸ';
            
            const days = Math.floor(seconds / 86400);
            const hours = Math.floor((seconds % 86400) / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            
            let result = '';
            if (days > 0) result += `${days}å¤©`;
            if (hours > 0) result += `${hours}å°æ—¶`;
            if (minutes > 0) result += `${minutes}åˆ†é’Ÿ`;
            if (secs > 0 && days === 0) result += `${secs}ç§’`;
            
            return result || 'åˆšåˆš';
        }

        let cacheInfoData = [];

        async function loadCacheInfo() {
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000);
                
                const response = await fetch('/api/redis/cache-info', {
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (data.success) {
                    cacheInfoData = data.cacheInfo;
                    showAlert(`æˆåŠŸåŠ è½½${cacheInfoData.length}ä¸ªç¼“å­˜é”®çš„ä¿¡æ¯`, 'success');
                    updateCacheInfoDisplay();
                } else {
                    showAlert('åŠ è½½ç¼“å­˜ä¿¡æ¯å¤±è´¥: ' + (data.message || 'æœªçŸ¥é”™è¯¯'), 'error');
                }
            } catch (error) {
                let errorMessage = 'åŠ è½½ç¼“å­˜ä¿¡æ¯å¤±è´¥';
                if (error.name === 'AbortError') {
                    errorMessage = 'è¯·æ±‚è¶…æ—¶';
                } else if (error.message) {
                    errorMessage = error.message;
                }
                showAlert(errorMessage, 'error');
                console.error('åŠ è½½ç¼“å­˜ä¿¡æ¯å¤±è´¥:', error);
            }
        }

        function showCacheDetails() {
            const container = document.getElementById('cacheInfoContainer');
            if (container.style.display === 'none') {
                if (cacheInfoData.length === 0) {
                    showAlert('è¯·å…ˆåŠ è½½ç¼“å­˜ä¿¡æ¯', 'warning');
                    return;
                }
                container.style.display = 'block';
                updateCacheInfoDisplay();
            } else {
                container.style.display = 'none';
            }
        }

        function updateCacheInfoDisplay() {
            const content = document.getElementById('cacheInfoContent');
            if (cacheInfoData.length === 0) {
                content.innerHTML = '<p style="color: #666;">æš‚æ— ç¼“å­˜æ•°æ®</p>';
                return;
            }

            let html = '<table style="width: 100%; border-collapse: collapse; font-size: 12px;">';
            html += '<thead><tr style="background: #f0f0f0;"><th style="padding: 5px; border: 1px solid #ddd;">é”®å</th><th style="padding: 5px; border: 1px solid #ddd;">ç±»å‹</th><th style="padding: 5px; border: 1px solid #ddd;">TTL</th><th style="padding: 5px; border: 1px solid #ddd;">çŠ¶æ€</th></tr></thead>';
            html += '<tbody>';
            
            for (const cache of cacheInfoData) {
                const statusColor = cache.expired ? '#f44336' : (cache.ttl === -1 ? '#2196F3' : '#4CAF50');
                const statusText = cache.expired ? 'å·²è¿‡æœŸ' : (cache.ttl === -1 ? 'æ°¸ä¸è¿‡æœŸ' : 'æ­£å¸¸');
                
                html += `<tr>`;
                html += `<td style="padding: 3px; border: 1px solid #ddd; word-break: break-all;">${cache.key}</td>`;
                html += `<td style="padding: 3px; border: 1px solid #ddd;">${cache.type}</td>`;
                html += `<td style="padding: 3px; border: 1px solid #ddd;">${formatTime(cache.ttl)}</td>`;
                html += `<td style="padding: 3px; border: 1px solid #ddd; color: ${statusColor};">${statusText}</td>`;
                html += `</tr>`;
            }
            
            html += '</tbody></table>';
            content.innerHTML = html;
        }

        // é¡µé¢åŠ è½½æ—¶è·å–RedisçŠ¶æ€
        document.addEventListener('DOMContentLoaded', function() {
            // é¡µé¢å¯è§æ€§å˜åŒ–æ—¶çš„å¤„ç†
            let refreshInterval = null;
            
            function startAutoRefresh() {
                if (refreshInterval) {
                    clearInterval(refreshInterval);
                }
                refreshInterval = setInterval(() => {
                    if (document.visibilityState === 'visible') {
                        loadRedisStatus();
                    }
                }, 30000);
            }
            
            function stopAutoRefresh() {
                if (refreshInterval) {
                    clearInterval(refreshInterval);
                    refreshInterval = null;
                }
            }
            
            // åˆå§‹åŠ è½½
            loadRedisStatus();
            
            // åŠ è½½TTLé…ç½®
            loadTtlConfig();
            
            // å¯åŠ¨è‡ªåŠ¨åˆ·æ–°
            startAutoRefresh();
            
            // é¡µé¢å¯è§æ€§å˜åŒ–æ—¶çš„å¤„ç†
            document.addEventListener('visibilitychange', function() {
                if (document.visibilityState === 'visible') {
                    loadRedisStatus();
                    startAutoRefresh();
                } else {
                    stopAutoRefresh();
                }
            });
            
            // é¡µé¢å¸è½½æ—¶æ¸…ç†å®šæ—¶å™¨
            window.addEventListener('beforeunload', function() {
                stopAutoRefresh();
            });
        });
    </script>
    <script src="/js/dark-mode.js"></script>
</body>
</html> 